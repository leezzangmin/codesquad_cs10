# 구현과정 상세 설명

## 1단계

* first_step.py 의 read_data_from_terminal() 함수를 통해 main_map_data 변수에 맵 데이터를 할당한다.
* 터미널을 통해 유저의 입력을 받을 때, 입력이 공백일 때 까지 계속 받는다.
* stage_data가 한줄씩 쌓여서 한 스테이지를 만들고, 한 스테이지가 모두 입력되면 map_data에 입력(append)된다.
* stage_data를 한 줄씩 입력 받을 때 부터 convert_symbol_and_number() 함수를 통해 기호가 숫자로 변환된 데이터가 저장된다. 숫자를 기호로 바꾸려면 함수의 is_symbol 인자에 False를 넣으면 동작한다.
* first_step.py 의 print_map() 함수에 main_map_data 변수를 전달함으로 각 스테이지의 정보를 출력한다. 바깥 반복문은 스테이지 단위로 반복하는 loop이고, 안쪽 반복문은 스테이지의 한 줄을 단위로 반복하는 loop이다. 스테이지에 한 줄씩 접근하며 convert_symbol_and_number() 함수의 리턴값을 출력하는 동시에 같은 레벨에서 calculate_map() 함수로 스테이지의 오브젝트가 몇 개인지, 유저의 위치가 어디인지 파악한다.
* 안쪽 반복문이 한번 반복되면 display_stage_feature() 함수로 파악된 가로크기, 세로크기, 구멍의 수, 공의 수, 플레이어 위치를 출력한다.


## 2단계

* first_step.py 의 read_data_from_terminal() 함수를 통해 main_map_data 변수에 맵 데이터를 할당한다.
* 테스트에서 요구한 스테이지 번호가 2번이므로 stage_number 변수에 1번째 원소를 나타내는 1을 할당한다.
* second_step.py 의 start_play_game() 함수를 사용해서 스테이지데이터와 스테이지 번호를 넘겨 목적한 프로그램의 동작을 시작한다.
* start_play_game() 함수에서 SOKOVAN 게임을 위해 필요한 사용자의 입력에 'q' 가 들어올때까지 무한반복 루프를 돈다.
* get_user_command() 함수를 통해 유저의 입력을 읽는다.
* is_valid_command() 함수를 통해 유저의 입력을 한 글자 단위로 유효한지 검색한다.
* 유효하다면 get_player_location() 함수를 통해 stage_data를 순차탐색하며 플레이어의 위치를 찾고 반환해서 playerX와 playerY에 할당한다.
* 계속해서 operate_command() 함수를 통해 명령 수행 후 결과를 출력한다. is_valid_command()를 통과한 상태므로 입력은 항상 유효하다. if문을 사용하지 않고 move_coordinates_dictionary 딕셔너리형 변수를 사용해서 커맨드 변수로 딕셔너리에 바로 접근할 수 있고, 접근한 기대값은 [0]번인덱스 X값 변화량, [1]번 인덱스 Y값 변화량, [2]번 인덱스는 안내 메세지이다.
* playerX, playerY 좌표 변수에 딕셔너리 변수 0,1번 인덱스 값을 더한 후의 좌표를 is_valid_location() 함수를 통해 유효한지 확인한다.
* 유효하다면 플레이어의 움직임이 성립된다는 뜻이므로 modify_stage_data() 함수를 통해 플레이어의 위치 데이터를 변화시키고 난 후 결과를 출력한다.
* 유효하지 않다면 display_stage() 함수를 통해 현 스테이지의 상태를 사용자에게 보여주고 에러메세지를 띄운다.


## 3단계

* 클래스 객체를 선언하는 동시에 게임 시작
* 'w','a','s','d','q','r' 외의 사용자의 입력은 무시
* 'O'와 'P'가 겹친 상태는 내부적으로 '5'로 저장해서 처리
* 'O' 와 'o'가 겹친 상태는 내부적으로 '6'으로 저장해서 처리
* 2단계에서의 함수를 대부분 재사용했음, 
* 클래스 공유 변수를 통해서 함수간에 매개변수로 큰 데이터를 옮기지 않아도 작동할 수 있음
* 게임 시작은 map_data 변수의 0(stage_number초기값)번 인덱스부터 시작함. 스테이지 클리어시 show_and_clear_stage() 함수로 stage_number변수를 조정하고 다음 라운드를 시작함
* 클리어 여부 판별은 is_clear() 함수로 stage_data를 순차탐색하며 구멍이 남아있으면 False, 없으면 True를 리턴함
* 플레이어 이동조건은 is_valid_location() 함수와 modify_stage_data() 함수로 대부분 구현했음 - 가려는 곳이 벽이나 맵의 범위 밖이라면 False를 리턴, 공이 포함된 지역을 민다면 그 다음 지역의 상태를 판단해서 값을 조정.

## 추가단계

* 클래스 객체를 생성하면 게임이 시작됨
* 기본적인 기능은 3단계에서의 Sokoban 클래스에 모두 구현되어있으므로 클래스를 가져와서 데이터변환, 되돌리기 기능만 추가
* 'w','a','s','d','q','r','u','U' 외의 사용자의 입력은 무시
* read_data_from_txtfile() 함수는 일반 txt파일을 읽어오는 기능의 함수라서 제거했음
* '일반 텍스트 에디터로 읽을 수 없는' 이라는 요구사항이 모호해서 일반 사용자가 임의로 해석할 수 없는 수준의 암호화를 하는 것으로 이해하고 함수를 작성했다. 각 문자의 아스키코드를 3씩 증가시키는 방법으로 암호화했고, 반대로 아스키코드를 3씩 감소시키는 방법으로 복호화했다.
* 클래스 변수로 스테이지 정보를 움직임별로 저장하는 배열변수 추가 - 스테이지 전체 정보를 깊은 복사해서 스택에 넣어놓고 사용할 예정, 되돌리기 기능과 되돌리기 취소는 같은 로직으로 작동됨
* 스택을 이용해 이전상태의 스테이지 정보를 deecopy()를 통해 저장하고 꺼내쓰는 방식으로 구현
